% Это основная команда, с которой начинается любой \LaTeX-файл. Она отвечает за тип документа, с которым связаны основные правил оформления текста.
\documentclass{article}

% Здесь идет преамбула документа, тут пишутся команды, которые настраивают LaTeX окружение, подключаете внешние пакеты, определяете свои команды и окружения. В данном случае я это делаю в отдельных файлах, а тут подключаю эти файлы.

% Здесь я подключаю разные стилевые пакеты. Например возможности набирать особые символы или возможность компилировать русский текст. Подробное описание внутри.
\usepackage{packages}

% Здесь я определяю разные окружения, например, теоремы, определения, замечания и так далее. У этих окружений разные стили оформления, кроме того, эти окружения могут быть нумерованными или нет. Все подробно объяснено внутри.
\usepackage{environments}

% Здесь я определяю разные команды, которых нет в LaTeX, но мне нужны, например, команда \tr для обозначения следа матрицы. Или я переопределяю LaTeX команды, которые работают не так, как мне хотелось бы. Типичный пример мнимая и вещественная часть комплексного числа \Im, \Re. В оригинале они выглядят не так, как мы привыкли. Кроме того, \Im еще используется и для обозначения образа линейного отображения. Подробнее описано внутри.
\usepackage{commands}

% Пакет для титульника исследовательского проекта
\usepackage{titlepage}


\setToResearch
\setTitle{Коммуникационная сложность}
\setGroup{198}
%сюда можно воткнуть картинку подписи
\setStudentSgn{\includegraphics[height=32pt]{sign2.png}}
\setStudent{Случ Дмитрий Борисович}
\setStudentDate{03.06.2022}
\setAdvisor{Подольский Владимир Владимирович}
\setAdvisorTitle{доцент д.ф.-м.н.}
\setAdvisorAffiliation{ФКН НИУ ВШЭ}

\setYear{2022}
\setYearOfStudy{3}



% С этого момента начинается текст документа
\begin{document}

% Эта команда создает титульную страницу
\makeTitlePage

% Здесь будет автоматически генерироваться содержание документа
\tableofcontents

% Данное окружение оформляет аннотацию: краткое описание текста выделенным абзацем после заголовка
\begin{abstract}
Я изучаю коммуникационную сложность функций являющихся композицией с функциями $EQ$, $IP_n$ и $DISJ$, а так же композицию с произвольной $XOR$ функцией. Для $EQ$ я привожу нижнюю оценку на одностороннюю коммуникационную сложность в детерминированном и квантовом точном случае, и верхнюю оценку в модели с общей монетой. Для композиции с $IP_n$ и $DISJ$ я привожу нижнюю оценку в квантовой односторонней модели с ограниченной вероятностью ошибкой.     
\end{abstract}

\section{Введение}
Композиции функций это интересный объект для анализа вычислительной сложности. Для функций $f \in \{0, 1\}^n$ и $g \in \{0, 1\}^b$ композиция определяется как $f \circ g :(\{0, 1\}^b)^n \to \{0, 1\}, f \circ g(x_{1, 1}, \ldots, x_{1, b}, \ldots, x_{n, 1}, \ldots, x_{n, b}) = f(g(x_{1, 1}, \ldots, x_{1, b}), \ldots, g(x_{n, 1}, \ldots, x_{n, b}))$. В частности я рассматриваю случай, когда $g \in \{0, 1\}^b \times \{0, 1\}^b \to \{0, 1\}$ коммуникационная задача (их называют гаджетом). Рассмотрим следующую коммуникационную задачу: у Алисы есть строка $x \in \{0, 1\}^{nb}$ у Боба $y \in \{0, 1\}^{nb}$ они хотят вычислить $f \circ g (x, y)$. Естественно использовать следующий протокол - Алиса и Боб применяют эффективный протокол для $f$ и когда протокол запрашивает очередной бит, применяют эффективный протокол для $g$. Теоремы поднятия выражают нижние границы на сложность вычисления композиций функций, через коммуникационную сложность гаджета, и сложность вычисления $f$, показывая в некоторых случаях, что такой наивный алгоритм оптимален. Я докажу несколько теорем поднятия для гаджетов $EQ$, $DISJ$ и $IP_n$. 
\subsection{Предварительная информация}
\subsubsection{Коммуникационная сложность}
Модель коммуникационной сложности была впервые представлена Yao~\cite{yao}. В детерминированном варианте, модель выглядит следующим образом. Есть два игрока Алиса и Боб, которые хотят вычислить функцию $f: X \times Y \to \{0, 1\}$ на аргументах $x \in X, y \in Y$, при этом Алиса знает $x$, а Боб $y$. Им необходимо коммуницировать, чтобы вычислить функцию, и коммуникация происходит в соответствии с протоколом $\mathcal{P}$ зависящим от $f$. Протокол определяет завершилась ли передача, и если не завершилась, какой игрок отправляет бит следующим. Эта информация зависит только от уже переданных бит, т.к. только эта информация общая для Алисы и Боба. Также если ходит Алиса, протокол определяет, что она должна отправить в зависимости от $x$ и уже переданной информации, если ходит Боб аналогично. После завершения коммуникации значение функции $f(x, y)$, должно быть возможно восстановить зная только переданные биты. Вычислительные ресурсы Алисы и Боба  считаются неограниченными, нас интересует только количество коммуникации между ними. Стоимость протокола это максимальное по всем входам $x \in X, y \in Y$, число бит переданных протоколом. Коммуникационной сложностью ($D_{cc}$) называется минимальная стоимость протокола. Иногда рассматривают немного другие модели. Например можно ослабить требование, что $f(x, y)$ однозначно определяется зная только переданные биты, и требовать чтобы только один из игроков мог восстановить $f(x, y)$. От этого сложность изменится не более чем на $1$ бит. Иногда требуют также, чтобы игроки отправляли биты по очереди(в оригинальной статье Yao было такое требование), сложность при этом изменится не более чем в 2 раза.
На протокол можно смотреть как на бинарное дерево, внутренние вершины соответствующие ходам Алисы помечены функциями от $x$, ходам Боба - функциями от $y$, листовые помечены $0$ или $1$ - значением функции для пар $(x, y)$ соответствующих листу. Переход в ребенка из вершины соответствует отправке бита, путь из корня до вершины однозначно соответствует уже переданным битам, зная этот путь мы можем понять листовая ли вершина, и если нет чьему ходу она соответствует, зная дополнительно к этому $x$ или $y$ мы определяем в какого ребенка пойдем. Оказывается~\cite{nisan}, что множества пар соответствующих одной вершине (в том числе листу) обладают структурой, которая называется комбинаторным прямоугольником.
\begin{definition}
    Комбинаторным прямоугольником называется подмножество $R \subseteq X \times Y$, такое что $\exists A \subseteq X, \exists B \subseteq Y, R = A \times B$. Комбинаторный прямоугольник $R$ называется монохромным, если $\exists v \in \{0, 1\} \forall (x, y) \in R, f(x, y) = v$.
\end{definition}
Методы построения нижних оценок на $D_{cc}$ основаны на том, что мы доказываем, что мы не сможем покрыть $X \times Y$ "маленьким" количеством монохромных прямоугольников, а значит листов в протоколе "много". Максимальное количество ребер на пути из корня в бинарном дереве, не меньше $\log_2(l)$, где $l$ количество листьев в дереве, таким образом если мы докажем что требуется не менее $l$ монохромных прямоугольников, чтобы покрыть $X \times Y$ это будет означать, что $D_{cc}(f) \geq \log_2(l)$. Одним из способов доказать, что прямоугольников "много" является техника fooling set~\cite{nisan}: 
\begin{theorem}
Пусть $f: \in \{0, 1\}^n \times \{0, 1\}^n \to \{0, 1\}$, $S \subset X \times Y, \exists z$ такой что $\forall (x', y'), (x'', y'') \in S, f(x', y') = f(x'', y'') = z$, при этом $f(x', y'') \neq z$ или $f(x'', y') \neq z$. Тогда $D_{cc}(f) \leq \log_2(|S|)$.
\begin{proof}
    Два элемента из $S$ не могут лежать в одном монохромном прямоугольнике. Допустим противное, $\exists X_R \subseteq X, Y_R \subseteq Y, R = X_R \times Y_R$ - монохромный прямоугольник. $\exists (x', y'), (x'', y'') \in S, (x', y'), (x'', y'') \in R$. Тогда $x', x'' \in X_R, y', y'' \in Y_R$, а значит $(x', y''), (x'', y') \in R = X_R \times Y_R$. Но это значит, что $R$ не монохромный. Противоречие. Значит невозможно покрыть $M_f$ менее чем $|S|$ монохромными прямоугольниками, значит в дереве не менее $|S|$ листов и глубина дерева не менее $\log_2 S$.   
\end{proof}
\end{theorem}
На основании метода fooling set доказывается следующая теорема~\cite{nisan}:
\begin{theorem}
    Пусть $f: \in \{0, 1\}^n \times \{0, 1\}^n \to \{0, 1\}$, а $M_f$ - коммуникационная матрица $f$. Тогда
    $$D_{cc}(f) \geq \log \operatorname{rk}(M_f).$$
\end{theorem}
Модель в которой передавать биты разрешается только Алисе, а после этого Боб должен назвать результат обозначим за $D_{cc}^{\to}$. Пусть сообщение, которое передает Алиса содержит не более $k$ бит. Это сообщение зависит только от $x$, таким образом существует разбиение на $X$ на $2^k$ классов, соответствующих каждому сообщению. Рассмотрим коммуникационную матрицу $M_f$, разбиение на $x$ соответствует разбиению на строках этой матрицы. Если все строки относящиеся к одному классу совпадают, то Бобу достаточно взять любой $x'$ из класса и $f(x', y)$ будет ответом. Если какие-то строки из класса не совпадают, то протокол не корректен, т.к. разбиение не зависит от $x$ и $y$ и мы можем подобрать $y'$, $x'$ и $x''$ такие, что $f(x', y') \neq f(x'', y')$ при этом $x'$ и $x''$ лежат в одном классе, и Алиса передала одинаковое сообщение. По принципу Дирихле, если $2^k < \operatorname{nrows}(M_f)$ в каком-то классе окажутся не совпадающие строки и протокол не корректен. Отсюда следует следующая теорема:~\cite{nisan}   
\begin{theorem}
    \label{th:dccto}
    Пусть $f \in \{0, 1\}^n\times \{0, 1\}^n \to \{0, 1\}$, $M_f$ коммуникационная матрица $f$. 
    Тогда $$D_{cc}^{\to}(f) = \ceil{\log_2{\operatorname{nrows}(M_f)}},$$ где $\operatorname{nrows}(M_f)$ - количество различных строк в матрице $M_f$. 
\end{theorem}
 Существует еще более ограниченная модель ($D^{||}_{cc}, SMP$), в которой Алисе и Бобу вообще не разрешается передавать информацию между собой, они должны передать какое-то сообщение рефери, который затем называет значение функции. \\
 В рандомизированных моделях игрокам разрешается подбрасывать монету и вычислять функцию с ошибкой с константной вероятностью. Я приведу алгоритм в модели, где оба игрока видят результат подброшенный монеты (public coin, $R^{pub}$), также существует модель где у каждого игрока источник случайности свой ($R^{priv})$. Существует обобщение техники fooling set и на рандомизированную модель, такая техника называется discrepancy. Для того чтобы ее описать понадобится ввести еще одну модель $R^{dist}_{\mu, \eps}$ - в этой модели на $X \times Y$ задано распределение вероятностей $\mu$ и вероятность входов $(x, y)$ на которых алгоритм ошибается должна быть ограничена $\eps$. Модели $R^{pub}_{\eps}$ и $R^{dist}_{\mu, \eps}$ связывает следующая теорема:~\cite{nisan}
 \begin{theorem}
    Пусть $f: \{0, 1\}^n\times\{0, 1\}^n \to \{0, 1\}$, тогда $R^{pub}_{\eps}(f) = \max_{\mu}R^{dist}_{\mu, \eps}(f)$.
 \end{theorem}
  Идея техники discrepancy заключается в том, что мы доказываем что для всех "больших" по вероятностной мере комбинаторных прямоугольников, вероятность входов из этого прямоугольника, на которых функция принимает значение 0 приблизительно равна вероятности входов из этого прямоугольника на которых функция принимает значение 1, таким образом если этот прямоугольник будет соответствовать листу ошибка на этом листе будет большой, а значит нам надо брать прямоугольники "меньше" и их понадобится много. Формально discrepancy определяется так:
  \begin{definition}
    Пусть $f \in \{0, 1\}^n\times \{0, 1\}^n \to \{0, 1\}$ функция, $R \subseteq X \times Y$ - прямоугольник. Определим $$\operatorname{Disc}_{\mu}(R, f) = |\operatorname{Pr}_{\mu}[f(x, y) = 0, (x, y) \in R] - \operatorname{Pr}_{\mu}[f(x, y) = 1, (x, y) \in R]|.$$
    Тогда discreptancy f при распределении $\mu$:
    $$\operatorname{Disc}_{\mu}(f) = \max_{R}\operatorname{Disc}_{\mu}(R, f).$$
  \end{definition}  
  Следующая теорема дает оценку на $R^{dist}_{\mu}$, а значит и на $R^{pub}$:~\cite{nisan}
   \begin{theorem}
    Пусть $f \in \{0, 1\}^n\times \{0, 1\}^n \to \{0, 1\}$ - функция, $\mu$ - распределение вероятности, тогда $$\forall \eps, R_{\mu, \eps}^{dist} \geq \log_2(\frac{2\eps}{\operatorname{Disc}_{\mu}(f)}).$$
   \end{theorem}
Обобщение этих моделей на квантовый случай введено Yao~\cite{yaoquant}, но более простое объяснение модели есть у R. de Wolf~\cite{wolf}.
\begin{definition}
    Квантовым состоянием называется линейная комбинация базисных векторов $\sum_{x \in \{0, 1\}^n}\alpha_{x}|x\rangle$ где $n$ обозначает число кубит. При этом вторая норма этой комбинации должна быть равна одному, т.е. $\sum_{x \in \{0, 1\}^n} \alpha^2 = 1$. 
\end{definition}
\begin{definition}
    Квантовым вентилем называется преобразование, которое действует на состояние умножением на унитарную матрицу. Пусть у вентиля $l$ входов с номерами $1, \ldots, l$ (без потери общности), а всего в состоянии $n$ кубит. Тогда вентиль действует на состояние умножением на матрицу $U \otimes I_2^{\otimes n - l}$, где $U$ унитарная матрица $2^l \times 2^l$, определяющая как вентиль действует на входы. 
\end{definition}
У Алисы и Боба есть какое-то состояние, которое разбито на часть, которая принадлежит Алисе, и часть которая принадлежит Бобу, Алиса и Боб могут неограниченно взаимодействовать со своими частями (т.е. применять к ним неограниченное количество вентилей), а так же "отправлять" кубиты - после чего общее состояние не меняется но меняется разбиение на кубиты Алисы и Боба. Количество отправленных кубитов необходимо минимизировать. Алиса и Боб могут добавлять кубиты, при этом общее состояние тензорно умножается на добавленный кубит, и если состояние можно представить как тензорное произведение, то часть этого произведения можно убрать. Я рассматриваю только односторонний случай таких моделей, когда Алиса отправляет кубиты Бобу. Количество операций без ошибки и с ограниченной вероятностью ошибки обозначим $Q_{E}^{\to}$ и $Q_{\eps}^{\to}$ соответственно. Модель в которой игрокам разрешается разделять запутанное состояние произвольного размера обозначим за $Q_{\eps, *}^{\to}$. В такой модели можно эмулировать рандомизированный алгоритм с публичной монетой, используя запутанной состояние в качестве источника случайности. H. Klauck доказал теоремы позволяющие строить оценки на квантовую коммуникационную сложность снизу.
~\cite{klauck}
\begin{theorem}
    \label{th:klauckexact}
    $f \in \{0, 1\}^n \to \{0, 1\}$. Пусть $M_f$ коммуникационная матрица $f$. 
    Тогда $Q_{E}^{\to}(f) = \ceil{\log_2{\operatorname{nrows}(M_f)}}$.
\end{theorem}
\begin{definition}Бинарная энтропия для $p \in (0, 1)$, $\mathbb{H}_{bin}$ определяется как энтропия Шеннона случайной величины принимающей значение $1$ с вероятностью $p$ и $0$ c вероятностью $1 - p$. 
$$\mathbb{H}_{bin}(p) = -p\ln(p) - (1 - p)\ln(1 - p).$$
\end{definition}
\begin{definition}
VC-размерность матрицы $M$ ($\operatorname{VC-dim}(M)$) это наибольшее $k$, такое, что существует $2^k \times k$ подматрица $M'$ матрицы $M$, все строки которой различны. Как было показано H.Klauck ~\cite{klauck} VC-размерность дает нижние оценки на квантовую одностороннюю сложность с ограниченной ошибкой.
\end{definition}
\begin{theorem}
    \label{th:klauckbounded}
    $f \in \{0, 1\}^n \to \{0, 1\}$, $M_f$ коммуникационная матрица $f$. 
    Тогда $$Q_{\eps}^{\to}(f) \geq (1 - \mathbb{H}_{bin}(\eps))\operatorname{VC-dim}(M_f),$$ $$Q_{\eps, *}^{\to}(f) \geq \frac{1}{2}(1 - \mathbb{H}_{bin}(\eps))\operatorname{VC-dim}(M_f).$$
\end{theorem} 

\subsubsection{Разложение Фурье}
Некоторые оценки можно построить рассматривая разложение Фурье функции над группой $\Z_2$. Пусть $[n] := \{1, \ldots, n\}$. Тогда для каждого натурального $n$ определим множество $2^n$ функций четности $\chi_S(x) = (-1)^{\sum_{i \in S}x_i}$ (Это вообще говоря характеры $\Z_2$). Пусть $f : \{0, 1\}^n \to \{0, 1\}$ функция на булевом кубе. Тогда коэффициентами Фурье  называются коэффициенты индексируемые подмножествами $[n]$:
$$\hat f(S) = \frac{1}{2^n}\sum_{x \in \{0, 1\}^n}f(x)\chi_S(x).$$
Функция $f$ представляется следующим образом(и коэффициенты для которых это представление существует единственны):
$$f(x) = \sum_{S \in [n]}\hat f(S)\chi_S(x).$$
Семейство множеств $S$ для которых коэффициенты Фурье не нулевые, обозначаются $\supp(f)$, отождествим множества $S$ с характеристическими векторами, размерность подпространства $\F_2^n$ натянутого на вектора для которых коэффициенты Фурье не нулевые называется размерностью Фурье ($\dim_f(f)$). Также для некоторых оценок нужны $p$-нормы Фурье. Они определяются следующим образом $$||f||_p = \sqrt[p]{\sum_{S \subset [n]}|\hat f(S)|^{p}}$$
с особыми случаями $0$ и $\infty$ нормами: $||f||_0 = |\supp(f)|$, $||f||_{\infty} = \max_{S \in [n]}(\hat f(S)).$   


\subsubsection{Композиция с гаджетами} 
Довольно хорошо изучена композиция с гаджетом $XOR$. Определим следующую модель вычислений:
% \begin{definition} Adaptive parity decision tree complexity($DT_{\oplus}$) -  минимальное количество запросов необходимых, чтобы точно вычислить $f: \{0, 1\}^n \to \{0, 1\}$ для любого входа $x$. Запросы могут зависеть от ответов на предыдущие запросы.
% \end{definition}
\begin{definition} Non-adaptive parity decision tree complexity($\operatorname{NADT}_{\oplus}$) -  минимальное количество множеств $S \in \{0, 1\}$, таких, что зная значения $\chi_{S}(x)$ можно однозначно восстановить $f$.
\end{definition}
Легко заметить, что для функции $f: \{0, 1\}^n \to \{0, 1\}, g(x, y) = f(x \oplus y)$, $D_{cc}^{\to}(g) \leq \operatorname{NADT}_{\oplus}$, действительно, пусть $S_1, \ldots, S_p$ - минимальный набор множеств, такой что зная $\chi_{S_1}(x), \ldots, \chi_{S_p}(x)$ можно однозначно восстановить $f(x)$. Тогда Алисе достаточно передать Бобу для каждого $j \in [p]$, $a_j = \bigoplus_{i \in S_j}x_i$, затем Боб вычислит $b_j  = a_j \oplus \bigoplus_{i \in S_j}y_i = \bigoplus_{i \in S_j}x_i \oplus y_i$, а зная эти значения возможно однозначно восстановить $g$. Оказывается верно равенство $D_{cc}^{\to}(g) = Q_{E}^{\to}(g) = \operatorname{NADT}_{\oplus}$. Оно следует из следующих теорем:
\begin{theorem}[Sanyal ~\cite{sanyalnapdt}]
\label{th:sanyal}
Для булевой функции $f : \{0, 1\}^n \to \{0, 1\}$, $\dim_f = \operatorname{NADT_{\oplus}}(f)$.
\end{theorem}
\begin{theorem}[Montanaro и Osbourne~\cite{montanaro}]
    \label{th:montanaro}
    Пусть $f:\{0, 1\}^n \to \{0, 1\}$ функция на булевом кубе. Определим $g(x, y) = f(x \oplus y)$. Тогда
    $$D_{cc}^{\to}(g) = Q_{E}^{\to}(g) = \dim_{f}(f).$$
\end{theorem}
При доказательстве этой теоремы, доказывается утверждение, которое потребуется мне в дальнейшем.
\begin{claim}[Montanaro и Osbourne~\cite{montanaro}]
    \label{cl:montanaro}
    Пусть $f:\{0, 1\}^n \to \{0, 1\}$ функция на булевом кубе. Определим $g(x, y) = f(x \oplus y)$.  Тогда
    $$\operatorname{nrows}(M_g) = 2^{\dim_{f}(f)}.$$
\end{claim} 
В модели с общей монетой, Montanaro и Osbourne~\cite{montanaro} показали следующие оценки:
\begin{theorem}
    Пусть $f: \{0, 1\}^n \to \{0, 1\}, g(x, y) = f(x \oplus y)$, тогда $R^{||, pub}(g) = O(||f||_1^2)$.
\end{theorem}
\begin{theorem}
    Пусть $f: \{0, 1\}^n \to \{0, 1\}, g(x, y) = f(x \oplus y)$, тогда $R^{||, pub}(g) = O(2^{n - 1}(1 - ||f||_{\infty}))$.
\end{theorem}
Некоторым аналогом $\operatorname{NADT}^{\oplus}$ для композиции с гаджетом $AND$ является следующая модель:
\begin{definition}
    Non-adaptive AND decision tree complexity($\operatorname{NAADT}$) -  минимальное количество множеств $S \in \{0, 1\}$, таких, что зная значения $\operatorname{AND}_{S}(x)$ можно однозначно восстановить $f$.  
\end{definition} 
По аналогии с $XOR$ функциями, для $AND$ функций можно доказать, что для $f: \{0, 1\}^{n} \to \{0, 1\}, g(x, y) = f(x \wedge y), D_{cc}^{\to}(g) \leq \operatorname{NAADT}(f)$, однако промежуток между оценкой снизу и оценкой сверху экспоненциальный. Mande et. al~\cite{mande} показали, что   
$$\log_2(\operatorname{NAPDT}(f)) \leq D_{cc}(g) \leq \operatorname{NAPDT}(f)$$ при этом нижняя оценка достигается с точностью до константы.\\
Для композиции с гаджетом скалярного произведения $IP$ верна следующая нижняя оценка, которую я обобщу в \autoref{sec:disj}:
\begin{theorem}[Mande et.al ~\cite{mande}]
    \label{th:mande}
    Пусть $f: \{0, 1\}^n \to \{0, 1\}$ функция зависящая от всех аргументов, $IP: \{0, 1\}^b \times \{0, 1\}^b \to \{0, 1\}$ скалярное произведение в $\F_2$, тогда $$Q^{\to}_{\eps}(f \circ IP) \geq (1 - \mathbb{H}_{bin}(\eps))n(b - 1), Q^{\to}_{\eps, *}(f \circ IP) \geq \frac{1}{2}(1 - \mathbb{H}_{bin}(\eps))n(b - 1).$$
\end{theorem} 
Я изучаю композицию с гаджетом $EQ$ в случае односторонней коммуникационной сложности, существуют нижние оценки на эту композицию в случае двусторонней модели.
%  Довольно легко заметить, что для любой нетривиальной функции $f: \{0, 1\}^n \to \{0, 1\}^n, EQ: \{0, 1\}^b \times \{0, 1\}^b \to \{0, 1\}$, $D_{cc}(f \circ EQ) \geq b$. 
\begin{definition}
    $\operatorname{DT}(f)$ - минимальное количество запросов к битам $x$, необходимое чтобы вычислить $f(x)$.
\end{definition}
\begin{definition}
    $\operatorname{L}(f)$ - минимальное количество листьев в решающем дереве $f(x)$.
\end{definition}
Является открытой проблемой верно ли, следующее утверждение:
\begin{proposition} 
    \label{prop:loff}
    $D_{cc}(f) \geq b\operatorname{DT}(f)$.
\end{proposition} Если бы это было так, то для любой зависящей от всех бит функции было бы верно, что $D_{cc}(f) \geq b(\log_2(n) - 1)$, т.к. в дереве должна быть хотя бы одна вершина зависящая от каждого бита, т.е. как минимум $n$ вершин. Оценки асимптотически лучшей чем эта, получить нельзя, поскольку композицию с функцией $ADDR: \{0, 1\}^{m + 2^m} \to \{0, 1\}, ADDR(i, x) = x_i, n = m + 2^m$, можно вычислить тривиальным алгоритмом за $O(b \log(n))$. Действительно, Алиса отправляет Бобу первые $m$ $b$-элементных блоков. Боб сравнивает их со своими блоками, и получает адрес $i \in \{0, 1\}^m$, который отправляет Алисе. Алиса отправляет Бобу блок с номером $m + i$, Боб сравнивает его со своим $m + i$ -тым блоком и отправляет Алисе ответ. Для такого алгоритма нужно $O(b \log n)$ бит коммуникации. Loff и Mukhopadhyay доказали близкую к предложению \ref{prop:loff} нижнюю оценку~\cite{loff}
\begin{theorem}
    Для $f \in \{0, 1\}^n \to \{0, 1\}, EQ: \{0, 1\}^b \times \{0, 1\}^b \to \{0, 1\}, b > 100 \log_2n$
    $$D_{cc}(f \circ EQ) = \Omega\bigg(b\frac{\log \operatorname{L}(f)}{\log n}\bigg).$$ 
\end{theorem}   

\subsection{Результаты}
    В \autoref{sec:disj} я доказываю нижнюю оценку на квантовую одностороннюю сложность с ограниченной ошибкой композиции произвольной функции, зависящей от всех аргументов и некоторого класса гаджетов, к которому принадлежат $DISJ$ и $IP_n$. В \autoref{sec:eq} я рассматриваю композицию с гаджетом $EQ$. В \autoref{sec:eqdet} я рассматриваю детерминированную модель и квантовую модель без ошибки, и доказываю в них, что для любой зависящей от всех аргументов функции нельзя достичь сложности лучшей, чем у тривиального алгоритма передающего все биты. В \autoref{sec:eqpub} я рассматриваю рандомизированную модель, и доказываю, что в ней композицию функции $f: \{0, 1\}^n \to \{0, 1\}$ с гаджетом $EQ$ можно вычислить за $O(n \log n)$ в не зависимости от размера блока, а так же что для некоторой $f$ не существует алгоритма работающего быстрее, чем за $O(n)$. В \autoref{sec:xordet} я обобщаю оценку из \autoref{sec:eqdet} на гаджеты являющиеся $XOR$-функциями. А именно я доказываю, что если $f: \{0, 1\}^n \to \{0, 1\}$ функция зависящая от всех аргументов, $h: \{0, 1\}^b \to \{0, 1\}, b \geq 2$ $D_{cc}^{\to}(f \circ h \circ XOR) = Q_{E}^{\to}(f \circ h \circ XOR) \geq n(\dim_f(h) - 1)$


\section{Композиция с $DISJ$ и $IP_n$}
\label{sec:disj}
Доказательство \autoref{th:mande} легко обобщается на случай $f \circ g \circ AND$, где $g: \{0, 1\}^b \to \{0, 1\}$ при этом $g$ принимает значение $0$ на строке из одних нулей, и $1$ на строках в которых ровно одна единица в произвольной позиции. $DISJ = \bigvee_{i=1}^{b}x_i \wedge y_i, IP_p = (\sum_{i=1}^{b}x_i \wedge y_i)^{p} \pmod{p}$, т.е. эти гаджеты представимы в виде $g \circ AND$, и $g$ удовлетворяет условию. Сформулирую и докажу обобщенную теорему
\begin{theorem}
    Пусть $f: \{0, 1\}^n \to \{0, 1\}$ функция зависящая от всех аргументов, а $g: \{0, 1\}^b \to \{0, 1\}$ принимает значение 0, на строке из одних нулей, и 1 на строках с ровно одной единицей. Значения на других строках могут быть произвольными. Тогда для $\eps \in (0, \frac{1}{2}), Q^{\to}_{\eps}(f \circ g \circ AND) \geq (1 - \mathbb{H}_{bin}(\eps))n(b - 1), Q^{\to}_{\eps, *}(f \circ g \circ AND) \geq \frac{1}{2}(1 - \mathbb{H}_{bin}(\eps))n(b - 1)$  
    \begin{proof}
    По \autoref{th:klauckbounded}, достаточно показать, что $VC(f \circ g) \geq n(b - 1)$. Обозначим за $M$ коммуникационную матрицу $f \circ g \circ AND$. Т.к. $f$ зависит от всех своих аргументов, $\forall i \exists z_1^{(i)}, \ldots, z_n^{(i)}, \exists v_i, f(z_1^{(i)}, \ldots, z_{i-1}^{(i)}, 0, z_{i+1}^{(i)}, \ldots, z_{n}^{(i)}) = v_i, f(z_1^{(i)}, \ldots, z_{i-1}^{(i)}, 1, z_{i+1}^{(i)}, \ldots, z_{n}^{(i)}) = 1 - v_i$.\\
    Для каждого $i \in 1, \ldots, n$ и $j \in 2, \ldots, b$ определим строку $y^{(i, j)}$ следующим образом. Для каждого $k \in 1, \ldots, n$ и $l \in 1, \ldots b$
    $$
    y_{k, l}^{(i, j)} = \begin{cases}
        z_{k}^{(i)} & \textit{если}\ i \neq k, l = 1\\
        1 & \textit{если}\ i = k, l = j\\
        0 & \textit{иначе}  
    \end{cases} 
    $$  
    Таким образом, для $k \neq i$ $k$-тый блок $y^{(i, j)}$ имеет вид $(z^{(i)}, 0^{b - 1})$, $i$-тый блок $y^{(i, j)}$ имеет вид $(0^{j - 1}, 1, 0^{n - j})$. Рассмотрим $n(b - 1)$ столбцов $M$ соответствующих $y^{(i, j)}$ и докажем что на этих столбцах существует подматрица $2^{n(b - 1)} \times n(b - 1)$ все строки которой различаются. Рассмотрим произвольную строку $c \in \{0, 1\}^{n(b - 1)}$. Я покажу что существует строка коммуникационной матрицы, ограничение которой на столбцы $y$ совпадает с строкой $c$. Определим $x \in \{0, 1\}^{nb}$ следующим образом. Для всех $i \in 1, \ldots, n$ и $j \in 2, \ldots, b$, $x_{i,1} = 1$ и $$x_{i, j} = \begin{cases}c_{i, j}&\textit{если}\ v_i = 0\\1 - c_{i, j} &\textit{если}\ v_i = 1\end{cases}$$ Т.е. первый элемент в блоке $x_{i}$ равен 1, а остальные совпадают с $c_i$ или с отрицанием $c_i$, в зависимости от значения $v_i$. Строка коммуникационной матрицы соответствующая $x$ при ограничении на столбцы $y$ дает строку $c$. Чтобы заметить это зафиксируем $i \in 1, \ldots, n$ и $j \in 2, \ldots, b$ и рассмотрим $f \circ g \circ AND(x, y^{(i, j)})$. Для каждого $k \neq i$ после применения $AND$ только первый бит в блоке может остаться не нулевым, он равен $z^{(i)}_{k}$ (действительно первый элемент блока $x_k$ равен 1, первый элемент блока $y^{(i, j)}_k$ равен $z_i$, а остальные 0 по определению), а значит $g \circ AND(x_{k}, y^{(i, j)}_{k}) = z^{(i)}_{k}$. Для $k = i$, только в $j$-том элементе $i$-того блока $y$ не ноль, а единица, более того $x_{i, j} = c_{i, j}$ если $v_i = 0$, и $1$ если $v_i = 1$, значит после применения конъюнкции останется только один ненулевой бит $x_{i, j}$, значит $g \circ AND(x_{i}, y^{(i, j)}_{i}) = x_{i, j}$. Таким образом после применения $g \circ AND$ строка имеет вид $z_1^{(i)}, \ldots, z_{i-1}^{(i)}, c_i, z_{i+1}^{(i)}, \ldots, z_{n}^{(i)}$, если $v_i = 0$, и $z_1^{(i)}, \ldots, z_{i-1}^{(i)}, 1 - c_i, z_{i+1}^{(i)}, \ldots, z_{n}^{(i)}$ если $v_i = 1$. По определению $z^{(i)}$ и $v_{i}$ значение $f$ примененной к этим входам равно $c_{i, j}$. Это завершает доказательство.
    \end{proof}
\end{theorem} 

\section{Композиция с $EQ$}
\label{sec:eq}
\subsection{Сложность в случае без ошибки}
\label{sec:eqdet}
\begin{theorem} 
    Пусть $f: \{0, 1\}^{n} \to \{0, 1\}$ функция зависящая от всех аргументов, а $EQ: \{0, 1\}^{b} \times \{0, 1\}^{b} \to \{0, 1\}$ функция равенства. Пусть $g(x, y) = f \circ EQ$ Тогда для $b\geq 2,$
    $Q_{E}^{\to}(g) = D_{cc}^{\to}(g) = nb$
\begin{proof}
По \autoref{th:dccto}, \autoref{th:klauckexact} $Q_{E}^{\to}(g) = D_{cc}^{\to}(g) = \ceil{\log_2{\operatorname{nrows(g)}}}$, где $\operatorname{nrows(g)}$ обозначает количество различных строк в коммуникационной матрице $g$. Докажем что в коммуникационной матрице $g = f \circ EQ$ все строки различны. Рассмотрим  $x^{(1)}, x^{(2)} \in \{0, 1\}^{nb}$, докажем что $\exists y \in \{0, 1\}^{nb}: g(x^{(1)}, y) \neq g(x^{(2)}, y)$. Дальше в записи нижние индексы обозначают номера $b$ элементных блоков, а не элементов. Не теряя общности(разница только в порядке индексов), пусть $x^{(1)}_{1,\ldots, l} = x^{(2)}_{1, \ldots, l}, \forall i > l, x^{(1)}_{i} \neq x^{(2)}_{i}$ Найдем такие $z_1, \ldots z_l$, что $\exists z_{l+1}, \ldots, z_{n}$, $f(z_1, \ldots, z_l, 0,\ldots, 0) \neq f(z_1, \ldots, z_l, z_{l+1}, \ldots, z_{n})$. Если таких $z_1, \ldots, z_l$ не существует, то функция зависит только от $l$ бит, а мы потребовали, что она зависит от $n$ бит. Тогда положим для $i \in 1,\ldots, l$ 
$$y_i = \begin{cases}x^{(1)}_i &\textit{если}\ z_i = 1\\t_i \in \{0, 1\}^b, t \neq x^{(1)}_{i} &\textit{иначе}\end{cases}$$ 
для $i \in l + 1,\ldots, n$ 
$$y_i = \begin{cases}x^{(2)}_i &\textit{если}\ z_i = 1\\t_i \in \{0, 1\}^b, t \neq x^{(1)}_{i}, t \neq x^{(2)}_{i} &\textit{иначе}\end{cases}$$Такое $t_i$ найдется, т.к. в блоке $2^b \geq 4$ элемента, а мы запрещаем использовать максимум 2 из них.  Но тогда для блока $i \leq l$, если $z_i = 1$ $EQ(x^{(2)}_i, y_i) = EQ(x^{(1)}_i, y_i) = EQ(x^{(1)}_i, x^{(1)}_i) = 1 = z_i$, если $z_i = 0$, $EQ(x^{(2)}_i, y_i) = EQ(x^{(1)}_i, y_i) = EQ(x^{(1)}_i, t) = 0 = z_i$. Для блока $i > l$ если $z_i = 1$, $EQ(x^{(1)}_i, y_i) = EQ(x^{(1)}_i, x^{(2)}_i) = 0, EQ(x^{(2)}_i, y_i) = EQ(x^{(2)}_i, x^{(2)}_i) = 1 = z_i$, если $z_i = 0$, $EQ(x^{(1)}_i, y_i) = EQ(x^{(1)}_i, t_i) = 0, EQ(x^{(2)}_i, y_i) = EQ(x^{(2)}_i, t_i) = 0 = z_i$. Таким образом  
$EQ(x^{(1)}, y) = z_1, \ldots, z_l, 0, \ldots, 0$, а $EQ(x^{(2)}, y) = z_1, \ldots, z_l, z_{l+1}, \ldots, z_{n}$ $\Rightarrow f\circ EQ(x^{(1)}, y) \neq f \circ EQ(x^{(2)}, y)$  
\end{proof}
\end{theorem} 
\subsection{Сложность в модели с публичной монетой}
\label{sec:eqpub}
В случае если мы разрешаем Алисе и Бобу ошибаться с ограниченной вероятностью, вычислить $f \circ EQ$ можно значительно быстрее. Известно, что в модели с ограниченной ошибкой, функцию равенства можно вычислить за $O(1)$. Обобщим этот алгоритм композицию с функцией равенства. 
\begin{theorem}
    $R^{||, pub}_{1/4}(f \circ EQ) = O(n \log n)$
    \begin{proof}
        Рассмотрим следующий алгоритм, для каждого блока Алиса генерирует $k$ случайных строк $a^{(j)}_{i,1}, \ldots, a^{(j)}_{i,b}$, и находит $c^{(j)}_i = \langle a^{(j)}_i, x_i \rangle$, где $\langle a^{(j)}_i, x_i \rangle$ - обозначает скалярное произведение в $\mathbb{F}_2$. Боб знает $a$ и находит $d^{(j)}_i = \langle a^{(j)}_i, y_i \rangle$. Затем Алиса и Боб отправляют рефери строки $c$ и $d$. Всего они передают $O(nk)$ бит. Для каждого блока $i$ для всех $j$ рефери сравнивает $c^{(j)}_i$ и $d^{(j)}_i$, и если все биты совпадают считает, что $z_i = 1$ иначе $z_i = 0$. Рефери отвечает что результат равен $f(z_1, \ldots, z_n)$. Если $x_i = y_i$, то $c^{(j)}_i = d^{(j)}_i$ т.к. это просто одинаковые суммы, значит мы найдем этот бит правильно. Если строки $x_i$ и $y_i$ различаются, то пусть $l$ первый бит, такой что $x_{i, l} \neq y_{i, l}$. Заметим, что $\langle x_i, a \rangle \oplus \langle y_i, a\rangle = \langle x_i \oplus y_i, a\rangle$ Пусть $a \in \{0, 1\}$ такая что $\langle x_i \oplus y_i, a \rangle = v$ Тогда заменим в $a$ $l$-тый бит на противоположный, полученную строку обозначим $a^{\oplus l}$. $\langle x_i \oplus y_i, a^{\oplus l} \rangle = 1 - v$. Таким образом количество $a$, таких что $\langle x_i \oplus y_i, a \rangle = 1$ равно $2^{b-1}$, а вероятность, что для случайно выбранной строки $a$, $\langle x_i, a \rangle \neq \langle y_i, a\rangle$ равна $\frac{1}{2}$. Мы генерируем $k$ строк, значит вероятность что мы неправильно выбрали $z_i$ для фиксированного $i$ равна $2^{-k}$, а вероятность того что мы неправильно выбрали $z_i$ хотя бы в одном блоке не больше чем $n2^{-k}$. Положим $k = \ceil{\log_2 n} + 1$, тогда $n2^{-k} \leq \frac{1}{4} = \eps$, т.е. рефери ошибается не более чем в $\frac{1}{4}$ случаях.        
    \end{proof}
\end{theorem}   

 Эта оценка точная(tight) с точностью до умножения на логарифм. Это можно доказать, рассмотрев композицию с функцией адресации $ADDR:\{0, 1\}^{m + 2^m} \to \{0, 1\}, ADDR(i, x) = x_i, n = m + 2^m$, VC-размерность такой композиции будет $\Omega(n)$. Она дает оценку снизу на квантовую сложность, с запутанным состоянием произвольного размера, а значит и на сложность в модели с публичной монетой. По сути мы будем использовать только один бит в блоке и сведем задачу к оценке VC-размерности композиции $ADDR\circ XOR$.
 \begin{theorem}
    $ADDR:\{0, 1\}^{m + 2^m} \to \{0, 1\}, n = m + 2^m, EQ:\{0, 1\}^b \times \{0, 1\}^b \to \{0, 1\}, g = ADDR \circ EQ, Q^{\to}_{\eps}(g) = \Omega(n), Q^{\to}_{\eps, *}(g) = \Omega(n)$
    \begin{proof}
        Для $i \in \{0, 1\}^m$ положим 
        $$y^{(i)}_{k,l} = 
        \begin{cases}
            1 - i_k&\textit{если}\ k \leq m, l = 1\\
            0&\textit{иначе}
        \end{cases}$$

    Для всех строк $c \in \{0, 1\}^{2^m}$ существует $x$, такой что соответствующая $x$ строка коммуникационной матрицы $M_g$ ограниченная на строки $y$ равна $c$. Действительно, положим 
    $$x_{k, l}  = \begin{cases}
        1 - c_{k-m + 1} &\textit{если}\ k > m, l = 1\\
        0 &\textit{иначе}
    \end{cases}$$
    В каждом блоке ненулевой элемент может стоять только на первой позиции, при этом в строке $y$ ненулевые элементы только в блоках с индексом не большим $m$, а в $x$ с большим. Для $k \leq m$ мы сравниваем блок $(1 - i_k, 0^{b - 1})$ с блоком $0^b$, блоки будут равны если $i_k = 1$, и не равны если $i_k = 0$. Аналогично блоки с $k > m$ будут равны если $c_{k - m + 1} = 1$ и не равны иначе. Таким образом $g(y^{(i)}, x) = ADDR(i, c) = c_i$. Значит $\operatorname{VC-dim}(g) = \Omega(n)$, а значит по \autoref{th:klauckbounded} $Q^{\to}_{\eps}(g) = \Omega(n), Q^{\to}_{\eps, *}(g) = \Omega(n)$.
\end{proof}
 \end{theorem}
\section{Композиция с XOR функциями}
\label{sec:xordet}
Можно заметить, что функция $EQ$ которую мы рассматривали представима в виде $\wedge_{i=1}^{b}x_i\oplus y_i\oplus 1$. Ее коммуникационная сложность равна сложности функции $\wedge_{i=1}^{b}x_i\oplus y_i$, которая является $XOR$ функцией. Я обобщу результат для композиции $f \circ EQ$, на композицию $f \circ g \circ XOR$
\begin{theorem} 
    \label{th:xor}
    Пусть $f: \{0, 1\}^{n} \to \{0, 1\}$ функция зависящая от всех аргументов, $h: \{0, 1\}^{b} \to \{0, 1\}$. Пусть $g = h \circ XOR$. Тогда 
    $$Q_{E}^{\to}(f\circ g) = D_{cc}^{\to}(f \circ g) \geq n (\dim_f(h) - 1).$$
\begin{proof}
    Рассмотрим коммуникационную матрицу функции $g$. Как следует из \autoref{cl:montanaro} количество различных строк в этой матрице $2^{\dim_f(h)} = 2^p$. Выберем $2^p$ различных строк и если среди них есть строки все биты которых отличаются, выкинем из каждой пары таких строк одну. Осталось не менее $2^{p - 1}$ строк, обозначим множество соответствующих им значений параметров $A$. Т.к. все эти строки различны для любых $a', a'' \in A$, $\exists q: g(a', q) \neq g(a'', q)$. Также, т.к. мы выкинули из каждой пары полностью различных строк одну, для любых $a', a'' \in A$ существует бит в котором $a', a''$ совпадают, т.е. $\exists t$, такой что $g(a', t) = g(a'', t)$. Я докажу, что для любого $x$ такого, что $ \forall i, x_i \in A$ соответствующие этим $x$ строки коммуникационной матрицы $f \circ g$ различны. Всего не менее $2^{(p - 1)n}$ строк удовлетворяют этому свойству, значит по \autoref{th:dccto}, \autoref{th:klauckexact} $Q_{cc}^{\to}(f \circ g) = D_{cc}^{\to}(f \circ g) \geq n (p - 1)$.
    Рассмотрим $x^{(1)}, x^{(2)} : \forall i, x_i \in A$. Не теряя общности  $x^{(1)}_{1,\ldots, l} = x^{(2)}_{1, \ldots, l}, \forall i > l, x^{(1)}_{i} \neq x^{(2)}_{i}$. Для $i > l, \exists t_i$: $g(x^{(1)}_i, t_i) = g(x^{(2)}_i, t_i)$ т.к. $x_{i}^{(1)}, x_{i}^{(2)} \in A$. Положим $c_i := g(x^{(1)}_i, t_i)$ Найдем такие $z_1, \ldots z_l$, что $\exists z_{l+1}, \ldots, z_{n}$, $f(z_1, \ldots, z_l, c_{l+1},\ldots, c_n) \neq f(z_1, \ldots, z_l, z_{l+1}, \ldots, z_{n})$. Если таких $z_1, \ldots, z_l$ не существует, то $f$ зависит только от $l$ бит, а мы потребовали, что она зависит от $n$ бит. $\exists \alpha, \beta: h(\alpha) = 0, h(\beta) = 1$. В противном случае $h$ тождественное отображение, $\dim_f(h) = 1$ и утверждение теоремы тривиально.
    $\forall i > l, \exists q_i: g(x^{(1)}_i, q_i) \neq g(x^{(2)}_i, q_i)$ т.к. $x^{(1)}_{i}, x^{(2)}_i \in A$.
    Положим $d_i := g(x^{(1)}_i, q_i)$. Для $i \in 1, \ldots, l$ положим 
    $$
    y_i = \begin{cases}x^{(1)}_i\oplus \alpha &\textit{если}\ z_i = 0\\x^{(1)}_i\oplus \beta&\textit{иначе} \end{cases}$$
    для $i \in l + 1, \ldots, n$
    $$    
    y_i = \begin{cases}t_i&\textit{если}\ c_i = z_i\\q_i&\textit{если}\ c_i \neq z_i, c_i = d_i\\q_i \oplus x^{(1)}_i \oplus x^{(2)}_i &\textit{если}\ c_i \neq z_i, c_i \neq d_i\end{cases}$$  
    Но тогда для $i$-того блока, $i \leq l$, если $z_i = 0$, $g(x^{(2)}_i, y_i) = g(x^{(1)}_i, y_i) = h(x^{(1)} \oplus x^{(1)} \oplus \alpha) = h(\alpha) = 0 = z_i$, если $z_i = 1$, $g(x^{(2)}_i, y_i) = g(x^{(1)}_i, y_i) = h(x^{(1)} \oplus x^{(1)} \oplus \beta) = h(\beta) = 1 = z_i$.
    Для блоков $i > l$, если $c_i = z_i$, $g(x^{(1)}_i, y_i) = g(x^{(1)}_i, t_i) = c_i, g(x^{(2)}_i, y_i) = g(x^{(2)}_i, t_i) = c_i = z_i$. Если $c_i \neq z_i, c_i = d_i$, $g(x^{(1)}_i, y_i) = g(x^{(1)}_i, q_i) = d_i = c_i, g(x^{(2)}_i, y_i) = g(x^{(2)}_i, q_i) = 1 - d_i = 1 - c_i = z_i$. Если $c_i \neq z_i, c_i \neq d_i,$ $g(x^{(1)}_i, y_i) = g(x^{(1)}_i, q_i \oplus x^{(1)}_i \oplus x^{(2)}_i) = h(x^{(1)}_i \oplus q_i \oplus x^{(1)}_i \oplus x^{(2)}_i) = g(x^{(2)}_i, q_i) = 1 - d_i = c_i, g(x^{(2)}_i, y_i) = g(x^{(2)}_i, q_i \oplus x^{(1)}_i \oplus x^{(2)}_i) = g(x^{(1)}_i, q_i) = d_i = 1 - c_i = z_i$\\     
    Таким образом $f \circ g(x^{(1)}, y) = f(z_1, \ldots, z_l, c_{l+1}  \ldots, c_n) \neq f \circ g(x^{(2)}, y) = f(z_1, \ldots, z_l, z_{l+1}, \ldots, z_n)$. Это завершает доказательство   
\end{proof}
\end{theorem}
\begin{corollary}
    \label{cor:xor}
    Пусть $f \in \{0, 1\}^n \to \{0, 1\}, h \in \{0, 1\}^b \to \{0, 1\}$ булевы функции, тогда $$\dim_{f}(f \circ h) \geq n(\dim_f(h) - 1)$$
    \begin{proof}
        Рассмотрим $g(x, y) = h(x \oplus y)$. По \autoref{th:xor},  \autoref{th:montanaro} $\dim_f(f \circ h) = D_{cc}^{\to}(f \circ g) \geq n(\dim_f(h) - 1) $
    \end{proof}
\end{corollary}
\begin{corollary}
    Пусть $f \in \{0, 1\}^n \to \{0, 1\}, h \in \{0, 1\}^b \to \{0, 1\}$ булевы функции, тогда $$\operatorname{NADT}_{\oplus}(f \circ h) \geq n(\operatorname{NADT}_{\oplus}(h) - 1)$$
    \begin{proof}
        Рассмотрим $g(x, y) = h(x \oplus y)$. По \autoref{cor:xor}, \autoref{th:sanyal} $\operatorname{NADT}_{\oplus}(f \circ h) = \dim(f \circ h) \geq n(\dim_f(h) - 1) = n(\operatorname{NADT}_{\oplus}(h) - 1)$
    \end{proof}
\end{corollary}
% \section{Вычисление функции $EQ$ в квантовой модели, с неограниченным запутанным состоянием}
% \subsection{Верхняя оценка}
% Я приведу квантовый односторонний алгоритм, который вычисляет функцию $EQ$ передав всего 2 кубита. Алгоритм основан на алгоритме Deutsch-Jozsa и алгоритме вычисления функции $EQ'$ за $O(\log (n))$~\cite{wolf}. Функция $EQ'$ это частичная функция, которая отвечает $1$ если все аргументы попарно равны, и $0$ если ровно половина аргументов попарно равна, а вторая половина отличается, а иначе не определена. Идейно, мы сгенерируем по аналогии с рандомизированным(\autoref{sec:eqpub}) алгоритмом $2^n$ скалярных произведений, и сравним их с помощью алгоритма для $EQ'$, но вместо передачи кубит будет использовать запутанное состояние. В действительности хранить явно $2^n$ скалярных произведений конечно не надо.
% \paragraph{Алгоритм} Алиса и Боб сравнить две булевы строки $a$ и $b$ длины $n$. У них есть $n$ пар запутанных $(\frac{1}{\sqrt{2}})(|0\rangle + |1\rangle)$ кубит, их общее исходное состояние $\frac{1}{(\sqrt{2})^n}\sum_{x \in \{0, 1\}}|a, x, x, b\rangle$. Для начала им надо посчитать скалярное произведение. Это нетривиально сделать, т.к. у нас нет гейтов $AND$ и $XOR$, вместо них мы будем использовать $CCNOT$ и $CNOT$. Алиса и Боб добавляют каждый $n$ нулевых кубит $q^{(a)}_i$ и $q^{(b)}_i$ к своему состоянию, и выполняют $CCNOT(a_i, x_i, q^{(a)}_i)$ и $CCNOT(b_i, x_i, q^{(b)}_i)$ соответственно. После этого $q^{(a)}_i = a_i \wedge x_i, q^{(b)}_i = b_i \wedge x_i$. Теперь последовательно применяем $CNOT(q^{(a)}_i, q^{(a)}_{i + 1})$ и $CNOT(q^{(b)}_i, q^{(b)}_{i + 1})$. Теперь у нас в кубитах $q$ находятся скалярные произведения на префиксах. Алиса добавляет единичный кубит $h$, переводит его в состояние $|0\rangle - |1\rangle$ вентилем Адамара, и применяет $CNOT(h, q^{(a)}_{n})$. Алиса отправляет кубит $q^{(a)}_{n}$ Бобу, и он применяет $CNOT(q^{(b)}_n, q^{(a)}_n)$ после чего Алиса применяет обратные операции к кубитам $q^{(a)}_1, \ldots, q^{(a)}_{n - 1}$, а Боб к кубитам $q^{(b)}_1, \ldots, q^{(b)}_{n}$ после чего они перестают быть запутанными и их можно удалить. В кубите $q^{(a)}_n$ находится состояние $(a \oplus b, x)$ Получившееся состояние $$\frac{1}{(\sqrt{2})^{n + 1}}\sum_{x \in \{0, 1\}^n}|x,x\rangle\otimes(|(a \oplus b, x)\rangle - |(a \oplus b, x) \oplus 1\rangle)$$
% Расписав отдельно случай, когда $(a \oplus b, x)$ равно 0 и 1 получим:
% $$\frac{1}{(\sqrt{2})^{n + 1}}\sum_{x \in \{0, 1\}^n}|x,x\rangle(-1)^{(a \oplus b, x)}\otimes(|0\rangle - |1\rangle)$$
% Боб убирает последний кубит
% $$\frac{1}{(\sqrt{2})^{n}}\sum_{x \in \{0, 1\}^n}|x,x\rangle(-1)^{(a \oplus b, x)}$$
% Алиса и Боб применяют преобразования Адамара ко всем оставшимся кубитам. Здесь $x.x$ обозначает конкатенацию 
% $$\frac{1}{(\sqrt{2})^{3n}}\sum_{x \in \{0, 1\}^n}(-1)^{(a \oplus b, x)}\Big(\sum_{y \in \{0, 1\}^{2n}}(-1)^{(x.x, y)}|y\rangle\Big)$$ 

% $$\frac{1}{(\sqrt{2})^{3n}}\sum_{y \in \{0, 1\}^{2n}}\Big(\sum_{x \in \{0, 1\}^{n}}(-1)^{(x.x, y)}(-1)^{(a \oplus b, x)}|y\rangle\Big)$$ 
% Алиса и Боб измеряют свои состояния. Найдем вероятность состояния $|0^{2n}\rangle$ быть измеренным
% $$\frac{1}{\sqrt{}}$$

% Здесь автоматически генерируется библиография. Первая команда задает стиль оформления библиографии, а вторая указывает на имя файла с расширением bib, в котором находится информация об источниках.
\bibliographystyle{plainurl}
\bibliography{bibl}



% % С этого момента глобальная нумерация идет буквами. Этот раздел я добавил лишь для демонстрации возможностей LaTeX, его можно и нужно удалить и он не нужен для курсового проекта непосредственно.
% \appendix

% Проведем небольшой обзор возможностей \LaTeX. Далее идет обзорный кусок, который надо будет вырезать. Он приведен лишь для демонстрации возможностей \LaTeX.

% \section{Нумеруемый заголовок}
% Текст раздела
% \subsection{Нумеруемый подзаголовок}
% Текст подраздела
% \subsubsection{Нумеруемый подподзаголовок}
% Текст подподраздела

% \section*{Не нумеруемый заголовок}
% Текст раздела
% \subsection*{Не нумеруемый подзаголовок}
% Текст подраздела
% \subsubsection*{Не нумеруемый подподзаголовок}
% Текст подподраздела


% \paragraph{Заголовок абзаца} Текст абзаца

% Формулы в тексте набирают так $x = e^{\pi i}\sqrt{\text{формула}}$. Выключенные не нумерованные формулы набираются либо так:
% \[
% x = e^{\pi i}\sqrt{\text{формула}}
% \]
% Либо так
% $$
% x = e^{\pi i}\sqrt{\text{формула}}
% $$
% Первый способ предпочтительнее при подаче статей в журналы AMS, потому рекомендую привыкать к нему.

% Выключенные нумерованные формулы:
% \begin{equation}\label{Equation1}
% % \label{имя-метки} эта команда ставит метку, на которую потом можно сослаться с помощью \ref{имя-метки}. Метки можно ставить на все объекты, у которых есть автоматические счетчики (номера разделов, подразделов, теорем, лемм, формул и т.д.
% x = e^{\pi i}\sqrt{\text{формула}}
% \end{equation}
% Или не нумерованная версия
% \begin{equation*}
% x = e^{\pi i}\sqrt{\text{формула}}
% \end{equation*}

% Уравнение~\ref{Equation1} радостно занумеровано.

% Лесенка для длинных формул
% \begin{multline}
% x = e^{\pi i}\sqrt{\text{очень очень очень длинная формула}}=\\
% \tr A - \sin(\text{еще одна очень очень длинная формула})=\\
% \cos z \Im \varphi(\text{и последняя длинная при длинная формула})
% \end{multline}

% Многострочная формула с центровкой
% \begin{gather}
% x = e^{\pi i}\sqrt{\text{очень очень очень длинная формула}}=\\
% \tr A - \sin(\text{еще одна очень очень длинная формула})=\\
% \cos z \Im \varphi(\text{и последняя длинная при длинная формула})
% \end{gather}

% Многострочная формула с ручным выравниванием. Выравнивание идет по знаку $\&$, который на печать не выводится.
% \begin{align}
% x = &e^{\pi i}\sqrt{\text{очень очень очень длинная формула}}=\\
% &\tr A - \sin(\text{еще одна очень очень длинная формула})=\\
% &\cos z \Im \varphi(\text{и последняя длинная при длинная формула})
% \end{align}

% \begin{theorem}
% Текст теоремы
% \end{theorem}
% \begin{proof}
% В специальном окружении оформляется доказательство.
% \end{proof}

% \begin{theorem}[Имя теоремы]
% Текст теоремы
% \end{theorem}
% \begin{proof}[Доказательство нашей теоремы]
% В специальном окружении оформляется доказательство.
% \end{proof}

% \begin{definition}
% Текст определения
% \end{definition}

% \begin{remark}
% Текст замечания
% \end{remark}

% \paragraph{Перечни:} Нумерованные
% \begin{enumerate}
% \item Первый
% \item Второй
% \begin{enumerate}
% \item Вложенный первый
% \item Вложенный второй
% \end{enumerate}
% \end{enumerate}

% Не нумерованные

% \begin{itemize}
% \item Первый
% \item Второй
% \begin{itemize}
% \item Вложенный первый
% \item Вложенный второй
% \end{itemize}
% \end{itemize}


% Здесь текст документа заканчивается
\end{document}
% Начиная с этого момента весь текст LaTeX игнорирует, можете вставлять любую абракадабру.
